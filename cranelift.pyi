import enum
import typing

class FuncRef:
    def __init__(self, index: int): ...
    index: int

class SigRef:
    def __init__(self, index: int): ...
    index: int

class Value:
    def __init__(self, index: int): ...
    index: int

class ValueLabel:
    def __init__(self, index: int): ...
    index: int

class Block:
    def __init__(self, index: int): ...
    index: int

class Variable:
    def __init__(self, index: int): ...
    index: int

class JumpTable:
    def __init__(self, index: int): ...
    index: int

class Inst:
    def __init__(self, index: int): ...
    index: int

class Constant:
    def __init__(self, index: int): ...
    index: int

class Immediate:
    def __init__(self, index: int): ...
    index: int

class StackSlot:
    def __init__(self, index: int): ...
    index: int

class DynamicStackSlot:
    def __init__(self, index: int): ...
    index: int

class DynamicType:
    def __init__(self, index: int): ...
    index: int

class UserExternalNameRef:
    def __init__(self, index: int): ...
    index: int

class GlobalValue:
    def __init__(self, index: int): ...
    index: int

class FuncId:
    def __init__(self, index: int): ...
    index: int

class TargetIsa:
    def __init__(self, triple: str, **features: str): ...

class Linkage(enum.IntEnum):
    Import = ...
    Local = ...
    Preemptible = ...
    Hidden = ...
    Export = ...

class CallConv(enum.IntEnum):
    Fast = ...
    Cold = ...
    Tail = ...
    SystemV = ...
    WindowsFastcall = ...
    AppleAarch64 = ...
    Probestack = ...
    Winch = ...

class Type(enum.IntEnum):
    INVALID = ...
    I8 = ...
    I16 = ...
    I32 = ...
    I64 = ...
    I128 = ...
    F16 = ...
    F32 = ...
    F64 = ...
    F128 = ...
    I8X2 = ...
    I8X2XN = ...
    I8X4 = ...
    I16X2 = ...
    F16X2 = ...
    I8X4XN = ...
    I16X2XN = ...
    F16X2XN = ...
    I8X8 = ...
    I16X4 = ...
    I32X2 = ...
    F16X4 = ...
    F32X2 = ...
    I8X8XN = ...
    I16X4XN = ...
    I32X2XN = ...
    F16X4XN = ...
    F32X2XN = ...
    I8X16 = ...
    I16X8 = ...
    I32X4 = ...
    I64X2 = ...
    F16X8 = ...
    F32X4 = ...
    F64X2 = ...
    I8X16XN = ...
    I16X8XN = ...
    I32X4XN = ...
    I64X2XN = ...
    F16X8XN = ...
    F32X4XN = ...
    F64X2XN = ...
    I8X32 = ...
    I16X16 = ...
    I32X8 = ...
    I64X4 = ...
    I128X2 = ...
    F16X16 = ...
    F32X8 = ...
    F64X4 = ...
    F128X2 = ...
    I8X32XN = ...
    I16X16XN = ...
    I32X8XN = ...
    I64X4XN = ...
    I128X2XN = ...
    F16X16XN = ...
    F32X8XN = ...
    F64X4XN = ...
    F128X2XN = ...
    I8X64 = ...
    I16X32 = ...
    I32X16 = ...
    I64X8 = ...
    I128X4 = ...
    F16X32 = ...
    F32X16 = ...
    F64X8 = ...
    F128X4 = ...
    I8X64XN = ...
    I16X32XN = ...
    I32X16XN = ...
    I64X8XN = ...
    I128X4XN = ...
    F16X32XN = ...
    F32X16XN = ...
    F64X8XN = ...
    F128X4XN = ...

    def lane_type(self) -> Type: ...
    def lane_of(self) -> Type: ...
    def log2_lane_bits(self) -> int: ...
    def lane_bits(self) -> int: ...
    def bounds(self, signed: bool) -> tuple[int, int]: ...
    @staticmethod
    def int(bits: int) -> Type | None: ...
    @staticmethod
    def int_with_byte_size(bytes: int) -> Type | None: ...
    def as_truthy_pedantic(self) -> Type: ...
    def as_truthy(self) -> Type: ...
    def as_int(self) -> Type: ...
    def half_width(self) -> Type | None: ...
    def double_width(self) -> Type | None: ...
    def is_invalid(self) -> bool: ...
    def is_special(self) -> bool: ...
    def is_lane(self) -> bool: ...
    def is_vector(self) -> bool: ...
    def is_dynamic_vector(self) -> bool: ...
    def is_int(self) -> bool: ...
    def is_float(self) -> bool: ...
    def log2_lane_count(self) -> int: ...
    def lane_count(self) -> int: ...
    def bits(self) -> int: ...
    def min_lane_count(self) -> int: ...
    def min_bits(self) -> int: ...
    def bytes(self) -> int: ...
    def by(self) -> Type: ...
    def vector_to_dynamic(self) -> Type | None: ...
    def dynamic_to_vector(self) -> Type | None: ...
    def split_lanes(self) -> Type | None: ...
    def merge_lanes(self) -> Type | None: ...
    def index(self) -> int: ...
    def wider_or_equal(self) -> bool: ...
    @staticmethod
    def target_pointer_type(isa: TargetIsa) -> Type: ...

class TrapCode:
    def __init__(self, value: int): ...
    STACK_OVERFLOW: TrapCode = ...
    HEAP_OUT_OF_BOUNDS: TrapCode = ...
    BAD_CONVERSION_TO_INTEGER: TrapCode = ...
    INTEGER_DIVISION_BY_ZERO: TrapCode = ...
    INTEGER_OVERFLOW: TrapCode = ...

class IntCC(enum.IntEnum):
    Equal = ...
    NotEqual = ...
    SignedLessThan = ...
    SignedGreaterThanOrEqual = ...
    SignedGreaterThan = ...
    SignedLessThanOrEqual = ...
    UnsignedLessThan = ...
    UnsignedGreaterThanOrEqual = ...
    UnsignedGreaterThan = ...
    UnsignedLessThanOrEqual = ...

    def without_equal(self) -> IntCC: ...
    def unsigned(self) -> IntCC: ...
    def complement(self) -> IntCC: ...
    def swap_args(self) -> IntCC: ...

class FloatCC(enum.IntEnum):
    Ordered = ...
    Unordered = ...
    Equal = ...
    NotEqual = ...
    OrderedNotEqual = ...
    UnorderedOrEqual = ...
    LessThan = ...
    LessThanOrEqual = ...
    GreaterThan = ...
    GreaterThanOrEqual = ...
    UnorderedOrLessThan = ...
    UnorderedOrLessThanOrEqual = ...
    UnorderedOrGreaterThan = ...
    UnorderedOrGreaterThanOrEqual = ...

    def complement(self) -> IntCC: ...
    def swap_args(self) -> IntCC: ...

class Endianness(enum.IntEnum):
    Little = ...
    Big = ...

class AliasRegion(enum.IntEnum):
    Heap = ...
    Table = ...
    Vmctx = ...

class AtomicRmwOp(enum.IntEnum):
    Add = ...
    Sub = ...
    And = ...
    Nand = ...
    Or = ...
    Xor = ...
    Xchg = ...
    Umin = ...
    Umax = ...
    Smin = ...
    Smax = ...

class Signature:
    def __init__(self, call_conv: CallConv): ...
    def add_param(self, type: Type) -> None: ...
    def add_return(self, type: Type) -> None: ...
    params: typing.Iterable[Type]
    returns: typing.Iterable[Type]

class MemFlags:
    def __init__(self): ...
    @staticmethod
    def trusted() -> MemFlags: ...
    def alias_region(self) -> AliasRegion | None: ...
    def set_alias_region(self, region: AliasRegion | None) -> None: ...
    def set_by_name(self, name: str) -> None: ...
    def endianness(self, native_endianness: Endianness) -> Endianness: ...
    def explicit_endianness(self) -> Endianness | None: ...
    def set_endianness(self, endianness: Endianness | None) -> None: ...
    def notrap(self) -> bool: ...
    def set_notrap(self) -> None: ...
    def can_move(self) -> bool: ...
    def set_can_move(self) -> None: ...
    def aligned(self) -> int: ...
    def set_aligned(self) -> None: ...
    def readonly(self) -> bool: ...
    def set_readonly(self) -> None: ...
    def checked(self) -> bool: ...
    def set_checked(self) -> None: ...
    def trap_code(self) -> TrapCode | None: ...
    def set_trap_code(self, trap_code: TrapCode | None) -> None: ...

class FunctionBuilder:
    def __init__(self): ...

    func_signature: Signature
    def signature_add_param(self, type: Type) -> None: ...
    def signature_add_return(self, type: Type) -> None: ...
    def current_block(self) -> Block | None: ...
    # def set_srcloc(self, srcloc: SourceLoc) -> None: ...
    def create_block(self) -> Block: ...
    def set_cold_block(self, block: Block) -> None: ...
    def insert_block_after(self, block: Block, after: Block) -> None: ...
    def switch_to_block(self, block: Block) -> None: ...
    def seal_block(self, block: Block) -> None: ...
    def seal_all_blocks(self) -> None: ...
    def try_declare_var(self, var: Variable, ty: Type) -> None: ...
    def declare_var(self, var: Variable, ty: Type) -> None: ...
    def declare_var_needs_stack_map(self, var: Variable) -> None: ...
    def try_use_var(self, var: Variable) -> Value: ...
    def use_var(self, var: Variable) -> Value: ...
    def try_def_var(self, var: Variable, val: Value) -> None: ...
    def def_var(self, var: Variable, val: Value) -> None: ...
    def set_val_label(self, val: Value, label: ValueLabel) -> None: ...
    def declare_value_needs_stack_map(self, val: Value) -> None: ...
    def create_jump_table(
        self,
        default: tuple[Block, list[Value]],
        data: typing.Iterable[tuple[Block, list[Value]]],
    ) -> None: ...
    def create_sized_stack_slot(
        self,
        stack_size: int,
        align_shift: int,
    ) -> StackSlot: ...
    def create_dynamic_stack_slot(
        self,
        stack_type: DynamicType,
    ) -> DynamicStackSlot: ...
    def import_signature(self, signature: Signature) -> SigRef: ...
    def import_function(
        self,
        name: str | UserExternalNameRef,
        signature: SigRef,
        colocated: bool = False,
    ) -> None: ...
    # def create_global_value(self, data: GlobalValueData) -> GlobalValue: ...
    def ensure_inserted_block(self) -> None: ...
    # def cursor(self) -> FuncCursor : ...
    def append_block_params_for_function_params(self, block: Block) -> None: ...
    def append_block_params_for_function_returns(self, block: Block) -> None: ...
    def finalize(self) -> None: ...
    def block_params(self, block: Block) -> list[Value]: ...
    def signature(self, sigref: SigRef) -> Signature | None: ...
    def append_block_param(self, block: Block, ty: Type) -> Value: ...
    def inst_results(self, inst: Inst) -> list[Value]: ...
    def change_jump_destination(
        self,
        inst: Inst,
        old_block: Block,
        new_block: Block,
    ) -> None: ...
    def is_unreachable(self) -> bool: ...
    def ins_jump(
        self, block_call_label: Block, block_call_args: typing.Iterable[Value]
    ) -> Inst: ...
    def ins_brif(
        self,
        c: Value,
        block_then_label: Block,
        block_then_args: typing.Iterable[Value],
        block_else_label: Block,
        block_else_args: typing.Iterable[Value],
    ) -> Inst: ...
    def ins_br_table(self, x: Value, jt: JumpTable) -> Inst: ...
    def ins_debugtrap(self) -> Inst: ...
    def ins_trap(self, trap_code: TrapCode) -> Inst: ...
    def ins_trapz(self, c: Value, trap_code: TrapCode) -> Inst: ...
    def ins_trapnz(self, c: Value, trap_code: TrapCode) -> Inst: ...
    def ins_return(self, rvals: typing.Iterable[Value]) -> Inst: ...
    def ins_call(self, fn_ref: FuncRef, args: typing.Iterable[Value]) -> Inst: ...
    def ins_call_indirect(
        self,
        sig: SigRef,
        callee: Value,
        args: typing.Iterable[Value],
    ) -> Inst: ...
    def ins_return_call(
        self, fn_ref: FuncRef, args: typing.Iterable[Value]
    ) -> Inst: ...
    def ins_return_call_indirect(
        self,
        sig: SigRef,
        callee: Value,
        args: typing.Iterable[Value],
    ) -> Inst: ...
    def ins_func_addr(self, i_addr: Type, fn_ref: FuncRef) -> Value: ...
    def ins_splat(self, txn: Type, x: Value) -> Value: ...
    def ins_swizzle(self, x: Value, y: Value) -> Value: ...
    def ins_x86_pshufb(self, x: Value, y: Value) -> Value: ...
    def ins_insertlane(self, x: Value, y: Value, imm: int) -> Value: ...
    def ins_extractlane(self, x: Value, imm: int) -> Value: ...
    def ins_smin(self, x: Value, y: Value) -> Value: ...
    def ins_umin(self, x: Value, y: Value) -> Value: ...
    def ins_smax(self, x: Value, y: Value) -> Value: ...
    def ins_umax(self, x: Value, y: Value) -> Value: ...
    def ins_avg_round(self, x: Value, y: Value) -> Value: ...
    def ins_uadd_sat(self, x: Value, y: Value) -> Value: ...
    def ins_sadd_sat(self, x: Value, y: Value) -> Value: ...
    def ins_usub_sat(self, x: Value, y: Value) -> Value: ...
    def ins_ssub_sat(self, x: Value, y: Value) -> Value: ...
    def ins_load(
        self,
        mem: Type,
        mem_flags: MemFlags,
        p: Value,
        offset32: int,
    ) -> Value: ...
    def ins_store(
        self,
        mem_flags: MemFlags,
        x: Value,
        p: Value,
        offset32: int,
    ) -> Inst: ...
    def ins_uload8(
        self,
        i_ext8: Type,
        mem_flags: MemFlags,
        p: Value,
        offset32: int,
    ) -> Value: ...
    def ins_sload8(
        self,
        i_ext8: Type,
        mem_flags: MemFlags,
        p: Value,
        offset32: int,
    ) -> Value: ...
    def ins_istore8(
        self,
        mem_flags: MemFlags,
        x: Value,
        p: Value,
        offset32: int,
    ) -> Inst: ...
    def ins_uload16(
        self,
        i_ext8: Type,
        mem_flags: MemFlags,
        p: Value,
        offset32: int,
    ) -> Value: ...
    def ins_sload16(
        self,
        i_ext8: Type,
        mem_flags: MemFlags,
        p: Value,
        offset32: int,
    ) -> Value: ...
    def ins_istore16(
        self,
        mem_flags: MemFlags,
        x: Value,
        p: Value,
        offset32: int,
    ) -> Inst: ...
    def ins_uload32(self, mem_flags: MemFlags, p: Value, offset32: int) -> Value: ...
    def ins_sload32(self, mem_flags: MemFlags, p: Value, offset32: int) -> Value: ...
    def ins_istore32(
        self,
        mem_flags: MemFlags,
        x: Value,
        p: Value,
        offset32: int,
    ) -> Inst: ...
    def ins_stack_switch(
        self,
        store_context_ptr: Value,
        load_context_ptr: Value,
        in_payload0: Value,
    ) -> Value: ...
    def ins_uload8x8(self, mem_flags: MemFlags, p: Value, offset32: int) -> Value: ...
    def ins_sload8x8(self, mem_flags: MemFlags, p: Value, offset32: int) -> Value: ...
    def ins_uload16x4(self, mem_flags: MemFlags, p: Value, offset32: int) -> Value: ...
    def ins_sload16x4(self, mem_flags: MemFlags, p: Value, offset32: int) -> Value: ...
    def ins_uload32x2(self, mem_flags: MemFlags, p: Value, offset32: int) -> Value: ...
    def ins_sload32x2(self, mem_flags: MemFlags, p: Value, offset32: int) -> Value: ...
    def ins_stack_load(self, mem: Type, ss: StackSlot, offset32: int) -> Value: ...
    def ins_stack_store(self, x: Value, ss: StackSlot, offset32: int) -> Inst: ...
    def ins_stack_addr(self, i_addr: Type, ss: StackSlot, offset32: int) -> Value: ...
    def ins_dynamic_stack_load(self, mem: Type, dss: DynamicStackSlot) -> Value: ...
    def ins_dynamic_stack_store(self, x: Value, dss: DynamicStackSlot) -> Inst: ...
    def ins_dynamic_stack_addr(self, i_addr: Type, dss: DynamicStackSlot) -> Value: ...
    def ins_global_value(self, mem: Type, gv: GlobalValue) -> Value: ...
    def ins_symbol_value(self, mem: Type, gv: GlobalValue) -> Value: ...
    def ins_tls_value(self, mem: Type, gv: GlobalValue) -> Value: ...
    def ins_get_pinned_reg(self, i_addr: Type) -> Value: ...
    def ins_set_pinned_reg(self, addr: Value) -> Inst: ...
    def ins_get_frame_pointer(self, i_addr: Type) -> Value: ...
    def ins_get_stack_pointer(self, i_addr: Type) -> Value: ...
    def ins_get_return_address(self, i_addr: Type) -> Value: ...
    def ins_iconst(self, narrow_int: Type, imm: int) -> Value: ...
    def ins_f32const(self, imm: float) -> Value: ...
    def ins_f64const(self, imm: float) -> Value: ...
    def ins_vconst(self, txn: Type, constant: Constant) -> Value: ...
    def ins_shuffle(self, a: Value, b: Value, imm: Immediate) -> Value: ...
    def ins_nop(self) -> Inst: ...
    def ins_select(self, c: Value, x: Value, y: Value) -> Value: ...
    def ins_select_spectre_guard(self, c: Value, x: Value, y: Value) -> Value: ...
    def ins_bitselect(self, c: Value, x: Value, y: Value) -> Value: ...
    def ins_x86_blendv(self, c: Value, x: Value, y: Value) -> Value: ...
    def ins_vany_true(self, a: Value) -> Value: ...
    def ins_vall_true(self, a: Value) -> Value: ...
    def ins_vhigh_bits(self, narrow_int: Type, a: Value) -> Value: ...
    def ins_icmp(self, cc: IntCC, x: Value, y: Value) -> Value: ...
    def ins_icmp_imm(self, cc: IntCC, x: Value, imm: int) -> Value: ...
    def ins_iadd(self, x: Value, y: Value) -> Value: ...
    def ins_isub(self, x: Value, y: Value) -> Value: ...
    def ins_ineg(self, x: Value) -> Value: ...
    def ins_iabs(self, x: Value) -> Value: ...
    def ins_imul(self, x: Value, y: Value) -> Value: ...
    def ins_umulhi(self, x: Value, y: Value) -> Value: ...
    def ins_smulhi(self, x: Value, y: Value) -> Value: ...
    def ins_sqmul_round_sat(self, x: Value, y: Value) -> Value: ...
    def ins_x86_pmulhrsw(self, x: Value, y: Value) -> Value: ...
    def ins_udiv(self, x: Value, y: Value) -> Value: ...
    def ins_sdiv(self, x: Value, y: Value) -> Value: ...
    def ins_urem(self, x: Value, y: Value) -> Value: ...
    def ins_srem(self, x: Value, y: Value) -> Value: ...
    def ins_iadd_imm(self, x: Value, imm: int) -> Value: ...
    def ins_imul_imm(self, x: Value, imm: int) -> Value: ...
    def ins_udiv_imm(self, x: Value, imm: int) -> Value: ...
    def ins_sdiv_imm(self, x: Value, imm: int) -> Value: ...
    def ins_urem_imm(self, x: Value, imm: int) -> Value: ...
    def ins_srem_imm(self, x: Value, imm: int) -> Value: ...
    def ins_irsub_imm(self, x: Value, imm: int) -> Value: ...
    def ins_sadd_overflow_cin(
        self,
        x: Value,
        y: Value,
        c_in: Value,
    ) -> tuple[Value, Value]: ...
    def ins_uadd_overflow_cin(
        self,
        x: Value,
        y: Value,
        c_in: Value,
    ) -> tuple[Value, Value]: ...
    def ins_uadd_overflow(self, x: Value, y: Value) -> tuple[Value, Value]: ...
    def ins_sadd_overflow(self, x: Value, y: Value) -> tuple[Value, Value]: ...
    def ins_usub_overflow(self, x: Value, y: Value) -> tuple[Value, Value]: ...
    def ins_ssub_overflow(self, x: Value, y: Value) -> tuple[Value, Value]: ...
    def ins_umul_overflow(self, x: Value, y: Value) -> tuple[Value, Value]: ...
    def ins_smul_overflow(self, x: Value, y: Value) -> tuple[Value, Value]: ...
    def ins_uadd_overflow_trap(
        self, x: Value, y: Value, trap_code: TrapCode
    ) -> Value: ...
    def ins_ssub_overflow_bin(
        self,
        x: Value,
        y: Value,
        b_in: Value,
    ) -> tuple[Value, Value]: ...
    def ins_usub_overflow_bin(
        self,
        x: Value,
        y: Value,
        b_in: Value,
    ) -> tuple[Value, Value]: ...
    def ins_band(self, x: Value, y: Value) -> Value: ...
    def ins_bor(self, x: Value, y: Value) -> Value: ...
    def ins_bxor(self, x: Value, y: Value) -> Value: ...
    def ins_bnot(self, x: Value) -> Value: ...
    def ins_band_not(self, x: Value, y: Value) -> Value: ...
    def ins_bor_not(self, x: Value, y: Value) -> Value: ...
    def ins_bxor_not(self, x: Value, y: Value) -> Value: ...
    def ins_band_imm(self, x: Value, imm: int) -> Value: ...
    def ins_bor_imm(self, x: Value, imm: int) -> Value: ...
    def ins_bxor_imm(self, x: Value, imm: int) -> Value: ...
    def ins_rotl(self, x: Value, y: Value) -> Value: ...
    def ins_rotr(self, x: Value, y: Value) -> Value: ...
    def ins_rotl_imm(self, x: Value, imm: int) -> Value: ...
    def ins_rotr_imm(self, x: Value, imm: int) -> Value: ...
    def ins_ishl(self, x: Value, y: Value) -> Value: ...
    def ins_ushr(self, x: Value, y: Value) -> Value: ...
    def ins_sshr(self, x: Value, y: Value) -> Value: ...
    def ins_ishl_imm(self, x: Value, imm: int) -> Value: ...
    def ins_ushr_imm(self, x: Value, imm: int) -> Value: ...
    def ins_sshr_imm(self, x: Value, imm: int) -> Value: ...
    def ins_bitrev(self, x: Value) -> Value: ...
    def ins_clz(self, x: Value) -> Value: ...
    def ins_cls(self, x: Value) -> Value: ...
    def ins_ctz(self, x: Value) -> Value: ...
    def ins_bswap(self, x: Value) -> Value: ...
    def ins_popcnt(self, x: Value) -> Value: ...
    def ins_fcmp(self, cc: FloatCC, x: Value, y: Value) -> Value: ...
    def ins_fadd(self, x: Value, y: Value) -> Value: ...
    def ins_fsub(self, x: Value, y: Value) -> Value: ...
    def ins_fmul(self, x: Value, y: Value) -> Value: ...
    def ins_fdiv(self, x: Value, y: Value) -> Value: ...
    def ins_sqrt(self, x: Value) -> Value: ...
    def ins_fma(self, x: Value, y: Value, z: Value) -> Value: ...
    def ins_fneg(self, x: Value) -> Value: ...
    def ins_fabs(self, x: Value) -> Value: ...
    def ins_fcopysign(self, x: Value, y: Value) -> Value: ...
    def ins_fmin(self, x: Value, y: Value) -> Value: ...
    def ins_fmax(self, x: Value, y: Value) -> Value: ...
    def ins_ceil(self, x: Value) -> Value: ...
    def ins_floor(self, x: Value) -> Value: ...
    def ins_trunc(self, x: Value) -> Value: ...
    def ins_nearest(self, x: Value) -> Value: ...
    def ins_bitcast(self, mem_to: Type, mem_flags: MemFlags, x: Value) -> Value: ...
    def ins_scalar_to_vector(self, txn: Type, s: Value) -> Value: ...
    def ins_bmask(self, int_to: Type, x: Value) -> Value: ...
    def ins_ireduce(self, int: Type, x: Value) -> Value: ...
    def ins_snarrow(self, x: Value, y: Value) -> Value: ...
    def ins_unarrow(self, x: Value, y: Value) -> Value: ...
    def ins_uunarrow(self, x: Value, y: Value) -> Value: ...
    def ins_swiden_low(self, x: Value) -> Value: ...
    def ins_swiden_high(self, x: Value) -> Value: ...
    def ins_uwiden_low(self, x: Value) -> Value: ...
    def ins_uwiden_high(self, x: Value) -> Value: ...
    def ins_iadd_pairwise(self, x: Value, y: Value) -> Value: ...
    def ins_x86_pmaddubsw(self, x: Value, y: Value) -> Value: ...
    def ins_uextend(self, int: Type, x: Value) -> Value: ...
    def ins_sextend(self, int: Type, x: Value) -> Value: ...
    def ins_fpromote(self, float_scalar: Type, x: Value) -> Value: ...
    def ins_fdemote(self, float_scalar: Type, x: Value) -> Value: ...
    def ins_fvdemote(self, x: Value) -> Value: ...
    def ins_fvpromote_low(self, a: Value) -> Value: ...
    def ins_fcvt_to_uint(self, int_to: Type, x: Value) -> Value: ...
    def ins_fcvt_to_sint(self, int_to: Type, x: Value) -> Value: ...
    def ins_fcvt_to_uint_sat(self, int_to: Type, x: Value) -> Value: ...
    def ins_fcvt_to_sint_sat(self, int_to: Type, x: Value) -> Value: ...
    def ins_x86_cvtt2dq(self, int_to: Type, x: Value) -> Value: ...
    def ins_fcvt_from_uint(self, float_to: Type, x: Value) -> Value: ...
    def ins_fcvt_from_sint(self, float_to: Type, x: Value) -> Value: ...
    def ins_isplit(self, x: Value) -> tuple[Value, Value]: ...
    def ins_iconcat(self, lo: Value, hi: Value) -> Value: ...
    def ins_atomic_rmw(
        self,
        ty: Type,
        mem_flags: MemFlags,
        op: AtomicRmwOp,
        p: Value,
        x: Value,
    ) -> Value: ...
    def ins_atomic_cas(
        self,
        mem_flags: MemFlags,
        p: Value,
        e: Value,
        x: Value,
    ) -> Value: ...
    def ins_atomic_load(self, ty: Type, mem_flags: MemFlags, p: Value) -> Value: ...
    def ins_atomic_store(self, mem_flags: MemFlags, x: Value, p: Value) -> Inst: ...
    def ins_fence(self) -> Inst: ...
    def ins_extract_vector(self, x: Value, imm: int) -> Value: ...

class ObjectProduct:
    def emit(self) -> bytes: ...

class ObjectModule:
    def __init__(self, isa: TargetIsa, name: str): ...
    def declare_function(
        self,
        name: str | UserExternalNameRef,
        linkage: Linkage,
        signature: Signature,
    ) -> FuncRef: ...
    def define_function(
        self,
        func_ref: FuncRef,
        function_builder: FunctionBuilder,
    ) -> None: ...
    def finish(self) -> ObjectProduct: ...

class JITModule:
    def __init__(self, isa: TargetIsa | None = None): ...
    def declare_function(
        self,
        name: str | UserExternalNameRef,
        linkage: Linkage,
        signature: Signature,
    ) -> FuncRef: ...
    def define_function(
        self,
        func_ref: FuncRef,
        function_builder: FunctionBuilder,
    ) -> None: ...
    def finalize_definitions(self) -> None: ...
    def get_finalized_function(self, func_ref: FuncRef) -> int: ...
